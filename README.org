#+options: toc:t
* Utilities for password handling, named objects, alist as db...

The package contains utilities that I needed in multiple projects that
- I did not find in public repositories and
- are so small that they do not deserve separate package/repository

** Named objects
#+BEGIN: lisp-fns-doc :section tz-utilities::@named-objects :package tz-utilities
Class NAMED streamlines creating "printable" named class instances.

Class NAMED-JSON allows easier handling and pretty-printing of alist
objects. Word JSON in name is probably a bad one, but this is what I use it for:
alists obtained from cl-json:decode-json calls

- =NAMED= (class)
   Use as a mixin/base class to ensure that the class has slot NAME. This slot is
   used to pretty-print the objects.

     Superclasses: (STANDARD-OBJECT)

- =GET-NAME= (generic-fn)
   Name of the object. If it is named object, value of the NAME slot, otherwise
   object itself (suitable for strings, numbers, etc.)

   Lambda list: (OBJECT)

- =NO-NAME= (condition)
   Condition thrown when an object of class NAMED has no NAME specified at
   creation.

- =NAMED-JSON= (class)
   Objects backed up/created from an alist structure (e.g., decoded json) that
   contains, among other, name/display name of the object.

     Superclasses: (NAMED)

- =MAKE-JSON-OBJECT= (function)
   Make instance of an object backed by an alist. Typically, sets name based on
   the value associated with NAME-KEYWORD, but another function to extract name can
   be specified with NAMED-FN.

   Lambda list: (JSON CLASS &KEY (NAME-KEYWORD :NAME)
                 (NAME-FN (ASSOCD-FOR NAME-KEYWORD)))


#+END:

** Password retrieval
#+BEGIN: lisp-fns-doc :section tz-utilities::@authinfo :package tz-utilities
Utilities to retrieve passwords from safer storage.

The idea is not to have passwords (and possibly relared configuration objects -
names, etc) in the code, but elsewhere, and ask for them when needed in a simple way.

Two backends are in place: authinfo files, and secret service API.

- =GET-AUTHINFO= (function)
   Get secret for machine MACHINE and login USERNAME.

   Store already found secrets in a cache and try to retrieve from cache before
   other storate is tried.

   Raise condition SECRET-NOT-FOUND if relevant secret is not found; it has established restart USE-VALUE

   Lambda list: MACHINE USERNAME

- =GET-AUTHINFO-BOTH= (function)
   Get user and secret for MACHINE.

   Store already found secrets in a cache and try to retrieve from cache before
   other storate is tried.

   Lambda list: MACHINE

- =*AUTHINFO-FILE*= (variable)
   Authinfo file to search secrets in.

- =SECRET-NOT-FOUND= (condition)
   Condition thrown when no relevant secret is found.


#+END:

** Alists as a DB
#+BEGIN: lisp-fns-doc :section tz-utilities::@alist-utilities :package tz-utilities
Add-hoc utilities for alist management.

Three operations on alists when they are used as key-value DB need to be defined:
- getting the value for key or nil (assocd),
- updating value for the key, unconditionally (update-alist)
- getting the value and updating it if it does not exist (get-or-update-alist)

- =ASSOCD= (function)
   Convenience shortcut for (cdr (assoc ...)), also known as alist-get in elisp.
   FIXME: this must be in some standard library, but I can't find it.

   Lambda list: ITEM ALIST &REST PARS

- =ASSOCD-FOR= (function)
   Function of one parameter (an alist) that extracts KEY from that alist

   Lambda list: KEY &REST PARS

- =CLIST-TO-LLIST= (function)
   Convert list of conses (e.g., used by hunchentoot) to list of lists
     (e.g., used for display in org mode).

   Lambda list: OBJECT

- =GET-OR-UPDATE-ALIST= (function)
   Get value associated with KEY in the ALIST; if it is not present,
   update ALIST with KEY and evaluate NEW-VAL-CODE as new VALUE.

   Lambda list: (ALIST KEY &REST ASSOC-PARS &KEY
                 &ALLOW-OTHER-KEYS) &BODY NEW-VAL-CODE

- =WITH-SMALL-CACHE= (macro)
   Return body, or it cached value. Caching is done on current and
   cached KEYs being same; keyword parameters KEY and TEST can modify
   what same means.

   The cache is implemented as an alist, so should be small to keep efficiency.

   Lambda list: (KEY &REST PARS-TEST) &BODY BODY

- =PRUNE-ALIST= (function)
   Remove duplicate entries from an alist.

   Lambda list: ALIST TEST

- =UPDATE-ALIST= (modify-macro)
   Set value for KEY in modified alist to NEW-VALUE

   Lambda list: #:PLACE KEY NEW-VALUE &REST TEST-PARS


#+END:
